<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Playing Snake Game - Full Screen Responsive</title>
    <style>
        /* Remove default margins and padding to use full screen */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        /* Make the canvas fill the entire screen */
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <!-- The canvas element where the game will be drawn -->
    <canvas id="gameCanvas"></canvas>

    <script>
        // Get the canvas element by its ID
        const canvas = document.getElementById('gameCanvas');
        // Get the 2D rendering context for drawing on the canvas
        let ctx = canvas.getContext('2d');

        // Game variables
        // These will be used to define the game grid's dimensions
        let tileCountX, tileCountY, gridSizeX, gridSizeY;
        // Initialize snake with starting position
        let snake = [];
        // Initial movement direction for the snake
        let velocityX = 1;
        let velocityY = 0;
        // Food position
        let food = {};
        // Score counter
        let score = 0;

        // Function to adjust canvas size when the window is resized
        function resizeCanvas() {
            // Set canvas width to window's width
            canvas.width = window.innerWidth;
            // Set canvas height to window's height
            canvas.height = window.innerHeight;
            // Recalculate game scale when resizing
            adjustGameScale();
        }
        // Add event listener for window resize
        window.addEventListener('resize', resizeCanvas);
        // Call resizeCanvas to set initial size
        resizeCanvas();

        // Function to adjust the game's scale based on the screen size
        function adjustGameScale() {
            // Calculate the number of tiles along the x-axis
            tileCountX = Math.floor(canvas.width / 20); 
            // Calculate the number of tiles along the y-axis
            tileCountY = Math.floor(canvas.height / 20);
            // Determine the size of each grid tile for x-axis
            gridSizeX = canvas.width / tileCountX;
            // Determine the size of each grid tile for y-axis
            gridSizeY = canvas.height / tileCountY;

            // Initialize or reposition snake only if it doesn't exist yet
            if (snake.length === 0) {
                snake = [{x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2)}];
            } else {
                // If snake exists, adjust its position to fit new grid size
                snake = snake.map(segment => ({
                    x: Math.floor(segment.x * (tileCountX / Math.max(tileCountX, tileCountY))),
                    y: Math.floor(segment.y * (tileCountY / Math.max(tileCountX, tileCountY)))
                }));
            }
            // Place food if it hasn't been placed yet
            if (Object.keys(food).length === 0) {
                placeFood();
            } else {
                // Adjust food position to match new grid size if it exists
                food = {
                    x: Math.floor(food.x * (tileCountX / Math.max(tileCountX, tileCountY))),
                    y: Math.floor(food.y * (tileCountY / Math.max(tileCountX, tileCountY)))
                };
            }
        }

        // Function to place food at a random position on the grid
        function placeFood() {
            do {
                // Generate random x and y coordinates for food
                food = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY)
                };
            // Ensure food doesn't spawn on the snake's body
            } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
        }

        // Function to get all safe moves for the snake
        function getSafeMoves(snakeHead) {
            const moves = [];
            const directions = [
                {x: 1, y: 0}, // Right
                {x: -1, y: 0}, // Left
                {x: 0, y: 1}, // Down
                {x: 0, y: -1} // Up
            ];

            for (let dir of directions) {
                const newHead = {x: snakeHead.x + dir.x, y: snakeHead.y + dir.y};
                // Check if the new position is within grid boundaries and not on the snake
                if (newHead.x >= 0 && newHead.x < tileCountX && newHead.y >= 0 && newHead.y < tileCountY 
                    && !snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
                    moves.push(dir);
                }
            }
            return moves;
        }

        // Calculate Manhattan distance between two points
        function distance(p1, p2) {
            return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
        }

        // Choose the best move for the snake based on proximity to food
        function chooseBestMove(snakeHead, food, safeMoves) {
            if (safeMoves.length === 0) return {x: velocityX, y: velocityY};

            // Sort moves based on distance to food
            const sortedMoves = safeMoves.sort((a, b) => {
                const distA = distance({x: snakeHead.x + a.x, y: snakeHead.y + a.y}, food);
                const distB = distance({x: snakeHead.x + b.x, y: snakeHead.y + b.y}, food);
                return distA - distB;
            });

            // Return the move that gets the snake closest to the food
            return sortedMoves[0];
        }

        // Function for AI to decide snake's next move
        function autoMoveSnake() {
            const safeMoves = getSafeMoves(snake[0]);
            const bestMove = chooseBestMove(snake[0], food, safeMoves);
            velocityX = bestMove.x;
            velocityY = bestMove.y;
        }

        // Main game loop
        function gameLoop() {
            // Calculate new head position based on current velocity
            let newHead = {x: snake[0].x + velocityX, y: snake[0].y + velocityY};

            // Check if the snake has hit the wall or itself
            if (newHead.x < 0 || newHead.x >= tileCountX || newHead.y < 0 || newHead.y >= tileCountY || 
                snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
                alert(`Game Over! Score: ${score}`);
                document.location.reload();
                return;
            }

            // Add new head to the front of the snake
            snake.unshift(newHead);

            // Check if the snake has eaten the food
            if (newHead.x === food.x && newHead.y === food.y) {
                score++; // Increase score
                placeFood(); // Place new food
            } else {
                // If no food was eaten, remove the last segment of the snake
                snake.pop();
            }

            // Clear the canvas for the new frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the snake
            ctx.fillStyle = 'green';
            snake.forEach(segment => {
                ctx.fillRect(segment.x * gridSizeX, segment.y * gridSizeY, gridSizeX - 2, gridSizeY - 2);
            });

            // Draw the food
            ctx.fillStyle = 'red';
            ctx.fillRect(food.x * gridSizeX, food.y * gridSizeY, gridSizeX - 2, gridSizeY - 2);

            // Draw the score
            ctx.fillStyle = "black";
            ctx.font = `${Math.min(gridSizeX, gridSizeY) / 2}px Arial`;
            ctx.fillText(`Score: ${score}`, gridSizeX, gridSizeY * 2);

            // AI decides the next move for the snake
            autoMoveSnake();
            // Set a timeout for the next frame (controls game speed)
            setTimeout(gameLoop, 100); 
        }

        // Start the game by placing food and initiating the game loop
        placeFood();
        gameLoop();
    </script>
</body>
</html>